import os 
import sys
import subprocess           # Execute shell commands 
from subprocess import PIPE                 
import binwalk              # Binwalk is used in the backened for firmware binary extraction
import re                   # regex for pattern matching

# For UI using tkinter
import tkinter as tk
from tkinter import StringVar, filedialog
from tkinter import ttk
from tkinter import messagebox
from tkinter import *

select_console_UI = "UI"  # If want to do on console, make this variable as "CONSOLE"
# Implementation for tkinter UI and take input from user via tkinter UI

if select_console_UI == "UI":
    print("You have chosen via UI!!")
    root=tk.Tk()
    root.geometry("400x400")
    root.title("Firmware Security Vulnerability Detection Framework")
    selected_font_title = ('times',24, 'bold')
    selected_font = ('times',18, 'bold')
    directory_path_provided = ""
    binary_path = ""
    binary_extracted_path = ""
    # display title on UI
    title_display_lable = Label (root, text='Firmware Security Vulnerability Detection Framework', width=50, font=selected_font_title, fg="blue")
    title_display_lable.grid(row=0, column=1)
    # Ask user if they have a raw binary or the extracted one via a drop down menu
    selected_option = ""
    selected_option_UI = StringVar()
    # selected_option_UI.set("Select the option")
    drop_options = OptionMenu(root, selected_option_UI, "Binary file", "Extracted binary directory")
    drop_options.grid(row = 4, column=1)
    option_select_button = tk.Button(root, text='submit', width=20, command=lambda:get_selected_option())
    option_select_button.grid(row=5,column=1)
    def get_selected_option():
        global selected_option
        selected_option = selected_option_UI.get()
        print(selected_option)
        if selected_option == "Binary file" :
            # # get_binary_path_UI()
            # frame_binary = LabelFrame(root, text="Binary file")
            # test_label = Label(frame_binary, text="Hello", width=30, font=selected_font)
            # test_label.grid(row=0, column =0)
            upload_binary_UI()
            # extract_binary_UI(binary_path)
            # display_file_structure_UI(binary_extracted_path)

        elif selected_option == "Extracted binary directory":
            # get_extracted_directory_path_UI()
            upload_extracted_directory_UI()
            # display_file_structure_UI(directory_path_provided)
        else :
            messagebox.showerror("Option selection", "Select correct option")

    
    # file_path_UI = StringVar()
    # folder_path_UI = StringVar()

    # For binary file upload via tkinter UI
    def get_binary_UI():
        selected_file_path = tk.filedialog.askopenfilename(filetypes=[("Binary", '.bin'),('All types', '*.*')])
        global binary_path 
        binary_path =  selected_file_path
        # file_path_UI.set(selected_file_path)
        messagebox.showinfo("Binary path", "Selected path is" + binary_path)
        extract_binary_UI(binary_path)
        display_file_structure_UI(binary_extracted_path)
        # print(filename)
        
    # For directory upload of extracted binary via tkinter UI
    def get_provided_directory_UI():
        selected_folder_path = tk.filedialog.askdirectory()
        global directory_path_provided 
        directory_path_provided = selected_folder_path
        # folder_path_UI.set(selected_folder_path)
        messagebox.showinfo("Directory path", "Selected path is" + directory_path_provided)
        display_file_structure_UI(directory_path_provided)
        # print(selected_path)

    # For upload of binary file
    def upload_binary_UI():
        file_upload_lable = tk.Label(root, text='Upload the file', width=30, font=selected_font)
        file_upload_lable.grid(row=10, column=1)
        file_upload_button = tk.Button(root, text='Upload File', width=20, command=lambda:get_binary_UI())
        file_upload_button.grid(row=11,column=1)
        # file_path_lable = tk.Label(root, textvariable=file_path_UI, fg="blue")
        # file_path_lable.grid(row=3, column=1)

    # For upload of extacted binary folder
    def upload_extracted_directory_UI():
        folder_path = StringVar()
        folder_upload_lable = tk.Label(root, text='Upload the folder', width=60, font=selected_font)
        folder_upload_lable.grid(row=10, column=1)
        folder_upload_button = tk.Button(root, text='Upload Folder', width=20, command=lambda:get_provided_directory_UI())
        folder_upload_button.grid(row=11,column=1)
        # folder_path_lable = tk.Label(root, textvariable=folder_path, fg="blue")
        # folder_path_lable.grid(row=9, column=1)

    # Function to traverse/look for a directory in the extracted binary
    def get_dir_path(directory_name, directory_path):
        result = "Not found"
        # Walking top-down from the root
        for root, dir, files in os.walk(directory_path):
            if directory_name in dir:
                return os.path.join(root, directory_name)
        return result

    # Binary extraction for provided binary file
    def extract_binary_UI(binary_file_path):
            # print("Extracting the binary %s" %binary_file_path)
            messagebox.showinfo("Binary Extraction", "Extracting the binary" + binary_file_path)

            try:
                # Using binwalk APIs - https://github.com/ReFirmLabs/binwalk/blob/master/API.md
                # binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True, entropy=True)  
                binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True)   
                # print("Extraction done. The extracted file tree is in file 'filestructure.txt' ")
                dir_path_part = get_dir_path("bin", ".")
                # Fetching the root path of the extracted binary
                global binary_extracted_path
                binary_extracted_path = re.sub('/bin', '', dir_path_part)
                messagebox.showinfo("Binary Extraction","Extraction done. The path is " + binary_extracted_path)

             # Printing file structure to filestructure.txt
            # list_d = subprocess.run(["tree","_tp-link-archer-gx90-router.bin*"])
                # os.system("tree _* > filestructure.txt") #replace os.system with subprocess
            except binwalk.ModuleException as e:
                # print ("Binwalk critical failure:", e)
                messagebox.showerror("Binary Extraction", "Extraction Error")

    # Display the extracted directory as tree structure on UI
    def display_file_structure_UI(directory_path):
        frame_for_directory_tree = tk.Frame(root, width=300,height=200, bg="blue" )
        directory_tree_view = ttk.Treeview(frame_for_directory_tree, show='tree')
        tree_vertical_display= tk.Scrollbar(frame_for_directory_tree, orient=tk.VERTICAL, command=directory_tree_view.yview)
        directory_tree_view.configure(yscroll=tree_vertical_display.set)
        directory = directory_path
        directory_tree_view.heading('#0', text='Dir: '+directory, anchor='w')
        path=os.path.abspath(directory)
        node = directory_tree_view.insert('','end', text=path, open=True)

        def traverse_directory(parent, path):
            for d in os.listdir(path):
                full_path=os.path.join(path,d)
                isdir = os.path.isdir(full_path)
                id = directory_tree_view.insert(parent, 'end', text=d, open=False)
                if isdir:
                    traverse_directory(id, full_path)

        traverse_directory(node, path)
        # tree_vertical_display.pack(side=tk.RIGHT, fill=tk.Y)
        # directory_tree_view.pack()
        # frame_for_directory_tree.pack()
        # tree_vertical_display.grid(row = 12, column = 4)
        directory_tree_view.grid(row=16, column = 1)
        frame_for_directory_tree.grid(row = 16, column = 1)

    root.mainloop()



# *******************************************************************************************************
# Function to take input from user via console
# Function to take the binary file path input from user on console
if select_console_UI == "CONSOLE" :
    print("You have chosen via Console!!")
    def take_binary_path():
        binary_path_input = input("Enter the path of the binary file: ")
        #Check if the file exists in the path
        assert os.path.isfile(binary_path_input), "File %s not found. Please enter the correct path of binary" %binary_path_input
        return binary_path_input

    # Function to take directly the path of the already extracted binary
    def take_extracted_directory_path():
        extracted_directory_path_input = input("Enter the path of the extracted directory: ")     
        assert os.path.isdir(extracted_directory_path_input), "Directory not found. Please enter the correct path"
        return extracted_directory_path_input

    # Function to extract the firmware binary if the path on binary is provided (not the extracted binary)
    def extract_binary(binary_file_path):
        print("Extracting the binary %s" %binary_file_path)
        try:
            # Using binwalk APIs - https://github.com/ReFirmLabs/binwalk/blob/master/API.md
            # binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True, entropy=True)  
            binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True)   
            print("Extraction done. The extracted file tree is in file 'filestructure.txt' ")
        # list_d = subprocess.run(["tree","_tp-link-archer-gx90-router.bin*"])
            os.system("tree _* > filestructure.txt") #replace os.system with subprocess
        except binwalk.ModuleException as e:
            print ("Binwalk critical failure:", e)

    # Function to traverse/look for a directory in the extracted binary
    def get_dir_path(directory_name, directory_path):
        result = "Not found"
        # Walking top-down from the root
        for root, dir, files in os.walk(directory_path):
            if directory_name in dir:
                return os.path.join(root, directory_name)
        return result

    # Function to look CVE database to report vulnerabilities w.r.t identified version number of the binary
    def cve_bin_tool():
        firmware_intake_options = input("Enter 1 for entering the binary path \nEnter 2 for entering the extracted file path: ")
        if(firmware_intake_options=='1'):
            bin_file_path = take_binary_path()
            os.system("rm -r _*")
            extract_binary(bin_file_path)
            dir_path_part = get_dir_path("bin", ".")
        # Fetching the root path of the extracted binary
            dir_path = re.sub('/bin', '', dir_path_part)

        elif(firmware_intake_options=='2'):
            dir_path = take_extracted_directory_path()
            
        else:
            print("Choose the correct option")
            return

        #with open('cve_checker.csv', 'w') as f:
            #f.write('cve-bin-tool %s \n' %dir_path)
            #cve_check = subprocess.Popen(['cve-bin-tool', dir_path, '-o cve_checker -f csv'], stdout=f)
        cve_check = subprocess.run(['cve-bin-tool', dir_path, '-o', 'cve_checker', '-f', 'csv'])


# Testing cve-bin-tool
# cve_bin_tool()
