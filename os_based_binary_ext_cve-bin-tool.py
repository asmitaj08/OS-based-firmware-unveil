import os 
import sys
import subprocess           # Execute shell commands 
from subprocess import PIPE                 
import binwalk              # Binwalk is used in the backened for firmware binary extraction
import re                   # regex for pattern matching

# For UI using tkinter
import tkinter as tk
from tkinter import StringVar, filedialog
from tkinter import ttk
from tkinter import messagebox
from tkinter import *
import webbrowser
# import pandas as pd # for csv file read
import csv

select_console_UI = "UI"  # If want to do on console, make this variable as "CONSOLE"
# Implementation for tkinter UI and take input from user via tkinter UI

if select_console_UI == "UI":
    print("You have chosen via UI!!")
    root=tk.Tk()
    root.geometry("400x400")
    root.title("Firmware Security Vulnerability Detection Framework")
    selected_font_title = ('times',24, 'bold')
    selected_font = ('times',18, 'bold')
    directory_path_provided = ""
    binary_path = ""
    binary_extracted_path = ""
    # display title on UI
    title_display_lable = Label (root, text='Firmware Security Vulnerability Detection Framework', width=50, font=selected_font_title, fg="blue")
    title_display_lable.grid(row=0, column=1)
    # Ask user if they have a raw binary or the extracted one via a drop down menu
    selected_option = ""
    selected_option_UI = StringVar()
    cve_bin_csv = StringVar()
    # selected_option_UI.set("Select the option")
    drop_options = OptionMenu(root, selected_option_UI, "Binary file", "Extracted binary directory")
    drop_options.grid(row = 4, column=1)
    option_select_button = tk.Button(root, text='submit', width=20, command=lambda:get_selected_option())
    option_select_button.grid(row=5,column=1)
    def get_selected_option():
        global selected_option
        selected_option = selected_option_UI.get()
        print(selected_option)
        if selected_option == "Binary file" :
            # # get_binary_path_UI()
            # frame_binary = LabelFrame(root, text="Binary file")
            # test_label = Label(frame_binary, text="Hello", width=30, font=selected_font)
            # test_label.grid(row=0, column =0)
            upload_binary_UI()
            # extract_binary_UI(binary_path)
            # display_file_structure_UI(binary_extracted_path)

        elif selected_option == "Extracted binary directory":
            # get_extracted_directory_path_UI()
            upload_extracted_directory_UI()
            # display_file_structure_UI(directory_path_provided)
        else :
            messagebox.showerror("Option selection", "Select correct option")

    
    # file_path_UI = StringVar()
    # folder_path_UI = StringVar()

    # For binary file upload via tkinter UI
    def get_binary_UI():
        selected_file_path = tk.filedialog.askopenfilename(filetypes=[("Binary", '.bin'),('All types', '*.*')])
        global binary_path 
        binary_path =  selected_file_path
        # file_path_UI.set(selected_file_path)
        messagebox.showinfo("Binary path", "Selected path is" + binary_path)
        extract_binary_UI(binary_path)
        display_file_structure_UI(binary_extracted_path)
        messagebox.showinfo("File structure","Extracted Binary Directory tree structure is displayed on UI. Wait for CVE-bin-tool..")
        cve_bin_tool_UI(binary_extracted_path)
        # print(filename)
        messagebox.showinfo("cve-bin-tool","CVE-bin tool tasks done!!")
        firmwalker_UI(binary_extracted_path)
        
    # For directory upload of extracted binary via tkinter UI
    def get_provided_directory_UI():
        selected_folder_path = tk.filedialog.askdirectory()
        global directory_path_provided 
        directory_path_provided = selected_folder_path
        # folder_path_UI.set(selected_folder_path)
        messagebox.showinfo("Directory path", "Selected path is" + directory_path_provided)
        display_file_structure_UI(directory_path_provided)
        messagebox.showinfo("File structure","Directory tree structure is displayed on UI. Wait for CVE-bin-tool..")
        cve_bin_tool_UI(directory_path_provided)
        # print(selected_path)
        messagebox.showinfo("cve-bin-tool","CVE-bin tool tasks done!!")
        messagebox.showinfo("firmwalker","Wait for firmwalker ... ")
        firmwalker_UI(directory_path_provided)
        messagebox.showinfo("firmwalker","Firmwalker done!! Click the link above to get sensitive file info")

    # For upload of binary file
    def upload_binary_UI():
        file_upload_lable = tk.Label(root, text='Upload the file', width=30, font=selected_font)
        file_upload_lable.grid(row=10, column=1)
        file_upload_button = tk.Button(root, text='Upload File', width=20, command=lambda:get_binary_UI())
        file_upload_button.grid(row=11,column=1)
        # file_path_lable = tk.Label(root, textvariable=file_path_UI, fg="blue")
        # file_path_lable.grid(row=3, column=1)

    # For upload of extacted binary folder
    def upload_extracted_directory_UI():
        folder_path = StringVar()
        folder_upload_lable = tk.Label(root, text='Upload the folder', width=60, font=selected_font)
        folder_upload_lable.grid(row=10, column=1)
        folder_upload_button = tk.Button(root, text='Upload Folder', width=20, command=lambda:get_provided_directory_UI())
        folder_upload_button.grid(row=11,column=1)
        # folder_path_lable = tk.Label(root, textvariable=folder_path, fg="blue")
        # folder_path_lable.grid(row=9, column=1)

    # Function to traverse/look for a directory in the extracted binary
    def get_dir_path(directory_name, directory_path):
        result = "Not found"
        # Walking top-down from the root
        for root, dir, files in os.walk(directory_path):
            if directory_name in dir:
                return os.path.join(root, directory_name)
        return result

    # Binary extraction for provided binary file
    def extract_binary_UI(binary_file_path):
            # print("Extracting the binary %s" %binary_file_path)
            messagebox.showinfo("Binary Extraction", "Extracting the binary" + binary_file_path)

            try:
                # Using binwalk APIs - https://github.com/ReFirmLabs/binwalk/blob/master/API.md
                # binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True, entropy=True)  
                binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True)   
                # print("Extraction done. The extracted file tree is in file 'filestructure.txt' ")
                dir_path_part = get_dir_path("bin", ".")
                # Fetching the root path of the extracted binary
                global binary_extracted_path
                binary_extracted_path = re.sub('/bin', '', dir_path_part)
                messagebox.showinfo("Binary Extraction","Extraction done. The path is " + binary_extracted_path)

             # Printing file structure to filestructure.txt
            # list_d = subprocess.run(["tree","_tp-link-archer-gx90-router.bin*"])
                # os.system("tree _* > filestructure.txt") #replace os.system with subprocess
            except binwalk.ModuleException as e:
                # print ("Binwalk critical failure:", e)
                messagebox.showerror("Binary Extraction", "Extraction Error")

    # Display the extracted directory as tree structure on UI
    def display_file_structure_UI(directory_path):
        frame_for_directory_tree = tk.Frame(root, width=300,height=200, bg="blue" )
        directory_tree_view = ttk.Treeview(frame_for_directory_tree, show='tree')
        tree_vertical_display= tk.Scrollbar(frame_for_directory_tree, orient=tk.VERTICAL, command=directory_tree_view.yview)
        directory_tree_view.configure(yscroll=tree_vertical_display.set)
        directory = directory_path
        directory_tree_view.heading('#0', text='Dir: '+directory, anchor='w')
        path=os.path.abspath(directory)
        node = directory_tree_view.insert('','end', text=path, open=True)

        def traverse_directory(parent, path):
            for d in os.listdir(path):
                full_path=os.path.join(path,d)
                isdir = os.path.isdir(full_path)
                id = directory_tree_view.insert(parent, 'end', text=d, open=False)
                if isdir:
                    traverse_directory(id, full_path)

        traverse_directory(node, path)
        # tree_vertical_display.pack(side=tk.RIGHT, fill=tk.Y)
        # directory_tree_view.pack()
        # frame_for_directory_tree.pack()
        # tree_vertical_display.grid(row = 12, column = 4)
        directory_tree_view.grid(row = 22, column = 1)
        frame_for_directory_tree.grid(row = 22, column = 1)

    # def import_csv_data():
    #     global cve_bin_csv
    #     cve_bin_csv.set("cve_checker.csv")
    #     df = pd.read_csv("cve_checker.csv")

    def cve_bin_tool_UI(dir_path):
                cve_check = subprocess.run(['cve-bin-tool', dir_path, '-o', 'cve_checker', '-f', 'csv'])
                # read and display result file generated from cve-bin-tool on UI
                TableMargin = Frame(root, width=500)
                TableMargin.grid(row=25, column=1)

                scrollbarx = Scrollbar(TableMargin, orient=HORIZONTAL)
                scrollbary = Scrollbar(TableMargin, orient=VERTICAL)
                tree = ttk.Treeview(TableMargin, columns=('vendor', 'product', 'version','cve_number',	'severity',	'score','cvss_version',	'cvss_vector','paths','remarks','comments'), height=200, selectmode="extended",
                                    yscrollcommand=scrollbary.set, xscrollcommand=scrollbarx.set)
                scrollbary.config(command=tree.yview)
                scrollbary.pack(side=RIGHT, fill=Y)
                scrollbarx.config(command=tree.xview)
                scrollbarx.pack(side=BOTTOM, fill=X)
                tree.heading('vendor', text="Vendor", anchor=W)
                tree.heading('product',text="Product", anchor=W)
                tree.heading('version',text="Version", anchor=W)
                tree.heading('cve_number', text="CVE Number", anchor=W)
                tree.heading('severity', text="Severity", anchor=W)
                tree.heading('score', text="Score", anchor=W)
                tree.heading('cvss_version', text="CVSS Version", anchor=W)
                tree.heading('cvss_vector', text="CVSS Vector", anchor=W)
                tree.heading('paths', text="Paths", anchor=W)
                tree.heading('remarks', text="Remarks", anchor=W)
                tree.heading('comments', text="Comments", anchor=W)

                tree.column('#0', stretch=NO, minwidth=0, width=0)
                tree.column('#1', stretch=NO, minwidth=0, width=120)
                tree.column('#2', stretch=NO, minwidth=0, width=120)
                tree.column('#3', stretch=NO, minwidth=0, width=120)
                tree.column('#4', stretch=NO, minwidth=0, width=120)
                tree.column('#5', stretch=NO, minwidth=0, width=120)
                tree.column('#6', stretch=NO, minwidth=0, width=120)
                tree.column('#7', stretch=NO, minwidth=0, width=120)
                tree.column('#8', stretch=NO, minwidth=0, width=120)
                tree.column('#9', stretch=NO, minwidth=0, width=120)
                tree.column('#10', stretch=NO, minwidth=0, width=120)
                tree.column('#11', stretch=NO, minwidth=0, width=120)
                tree.pack()
                # tree.grid(row=25, column=1)
                with open('cve_checker.csv') as f:
                    reader = csv.DictReader(f, delimiter=',')
                    for row in reader:
                        ven = row['vendor']
                        pro = row['product']
                        ver = row['version']
                        cve_n = row['cve_number']
                        sev = row['severity']
                        sco = row['score']
                        cvss_v = row['cvss_version']
                        cvss_t = row['cvss_vector']
                        pat = row['paths']
                        rem = row['remarks']
                        com = row['comments']

                        tree.insert("", 0, values=(ven, pro, ver,cve_n, sev, sco, cvss_v, cvss_t, pat, rem, com))


                # entry = tk.Entry(root, textvariable=cve_bin_csv).grid(row=30, column=20)
                # tk.Button(root, text='Browse Data Set',command=import_csv_data).grid(row=35, column=20)
                # with open("cve_checker.csv", newline = "") as file:
                #         reader = csv.reader(file)
                #         # r and c tell us where to grid the labels
                #         r = 25
                #         for col in reader:
                #             c = 1
                #             for row in col:
                #                 # i've added some styling
                #                 label = tk.Label(root, width = 10, height = 2, \
                #                                     text = row, relief = tk.RIDGE)
                #                 label.grid(row = r, column = c)
                #                 c += 1
                #             r += 1

    def callback(url):
        webbrowser.open_new(url)

    def firmwalker_UI(dir_path):
            firmwalker_output = subprocess.run(['./firmwalker.sh', dir_path])    
            #represent it on UI
            firmwalker_font = ('times',25, 'bold')
            Firmwalker_link = Label(root, text="Click here to check the sensitive files", fg="red", cursor="hand2", font=firmwalker_font)
            Firmwalker_link.grid(row=22, column=3)
            Firmwalker_link.bind("<Button-1>", lambda e: callback("firmwalker.txt"))



    root.mainloop()



# *******************************************************************************************************
# Function to take input from user via console
# Function to take the binary file path input from user on console
if select_console_UI == "CONSOLE" :
    print("You have chosen via Console!!")
    def take_binary_path():
        binary_path_input = input("Enter the path of the binary file: ")
        #Check if the file exists in the path
        assert os.path.isfile(binary_path_input), "File %s not found. Please enter the correct path of binary" %binary_path_input
        return binary_path_input

    # Function to take directly the path of the already extracted binary
    def take_extracted_directory_path():
        extracted_directory_path_input = input("Enter the path of the extracted directory: ")     
        assert os.path.isdir(extracted_directory_path_input), "Directory not found. Please enter the correct path"
        return extracted_directory_path_input

    # Function to extract the firmware binary if the path on binary is provided (not the extracted binary)
    def extract_binary(binary_file_path):
        print("Extracting the binary %s" %binary_file_path)
        try:
            # Using binwalk APIs - https://github.com/ReFirmLabs/binwalk/blob/master/API.md
            # binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True, entropy=True)  
            binwalk.scan(binary_file_path,signature=True, quiet=True, extract=True)   
            print("Extraction done. The extracted file tree is in file 'filestructure.txt' ")
        # list_d = subprocess.run(["tree","_tp-link-archer-gx90-router.bin*"])
            os.system("tree _* > filestructure.txt") #replace os.system with subprocess
        except binwalk.ModuleException as e:
            print ("Binwalk critical failure:", e)

    # Function to traverse/look for a directory in the extracted binary
    def get_dir_path(directory_name, directory_path):
        result = "Not found"
        # Walking top-down from the root
        for root, dir, files in os.walk(directory_path):
            if directory_name in dir:
                return os.path.join(root, directory_name)
        return result

    # Function to look CVE database to report vulnerabilities w.r.t identified version number of the binary
    def cve_bin_tool():
        firmware_intake_options = input("Enter 1 for entering the binary path \nEnter 2 for entering the extracted file path: ")
        if(firmware_intake_options=='1'):
            bin_file_path = take_binary_path()
            os.system("rm -r _*")
            extract_binary(bin_file_path)
            dir_path_part = get_dir_path("bin", ".")
        # Fetching the root path of the extracted binary
            dir_path = re.sub('/bin', '', dir_path_part)

        elif(firmware_intake_options=='2'):
            dir_path = take_extracted_directory_path()
            
        else:
            print("Choose the correct option")
            return

        #with open('cve_checker.csv', 'w') as f:
            #f.write('cve-bin-tool %s \n' %dir_path)
            #cve_check = subprocess.Popen(['cve-bin-tool', dir_path, '-o cve_checker -f csv'], stdout=f)
        cve_check = subprocess.run(['cve-bin-tool', dir_path, '-o', 'cve_checker', '-f', 'csv'])
        firmwalker_output = subprocess.run(['./firmwalker.sh', dir_path])



# Testing cve-bin-tool
# cve_bin_tool()
